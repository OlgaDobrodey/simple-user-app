1. **Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?**

    - Вернется из блока finally.
        - public static String method() {

          try { return "SomeString";}

          catch(Exception ex) { return "Catch message";}

          finally { return "Finally message";}

      //Вывод
      Finally message

2. **Как расшифровывается SOLID**

- S – Single Responsibility (Принцип единственной ответственности)
- O — Open-Closed (Принцип открытости-закрытости)
- L — Liskov Substitution (Принцип подстановки Барбары Лисков)
- I — Interface Segregation (Принцип разделения интерфейсов)
- D — Dependency Inversion (Принцип инверсии зависимостей)

3. **GRASP
   принципы** [general responsibility assignment software patterns ](https://bool.dev/blog/detail/grasp-printsipy)

- Информационный эксперт (Information Expert)
- Создатель (Creator)
- Контроллер (Controller)
- Слабое зацепление (Low Coupling)
- Чистая выдумка (Pure Fabrication)
- Перенаправление (Indirection)
- Устойчивость к изменениям (Protected Variations)

4. **Может ли один блок catch отлавливать несколько исключений**

- В Java 7 стала доступна новая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком
  catch:
    - try {  
      ... } catch( IOException | SQLException ex ) {  
      logger.log(ex);
      throw ex;
      }

5. **Что вы знаете о OutOfMemoryError**

OutOfMemoryError выбрасывается, когда виртуальная машина Java не может выделить (разместить) объект из-за нехватки
памяти, а сборщик мусора не может высвободить ещё.

Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип OutOfMemoryError зависит от того, в какой
из них не хватило места.
Области памяти

- ***java.lang.OutOfMemoryError: Java heap space***
  Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые программно в вашем
  приложении. Размер задается параметрами -Xms и -Xmx. Если вы пытаетесь создать объект, а места в куче не осталось, то
  получаете эту ошибку. Обычно проблема кроется в утечке памяти, коих бывает великое множество, и интернет просто
  пестрит статьями на эту тему.

- ***java.lang.OutOfMemoryError: PermGen space***
  Данная ошибка возникает при нехватке места в Permanent области, размер которой задается параметрами -XX:PermSize и
  -XX:MaxPermSize.

- ***java.lang.OutOfMemoryError: GC overhead limit exceeded***
  Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти
  осталось мало и GC постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью
  параметра -XX:-UseGCOverheadLimit, но, конечно же, её надо не отключать, а либо решать проблему утечки памяти, либо
  выделять больше объема, либо менять настройки GC.

- ***java.lang.OutOfMemoryError: unable to create new native thread***
  Выбрасывается, когда нет возможности создать еще потоки.

6. **GOF** "банды четырёх (GoF)" **Порождающие паттерны**

- Порождающие паттерны — это паттерны, которые абстрагируют процесс инстанцирования или, иными словами, процесс
  порождения классов и объектов. Среди них выделяются следующие:

- Абстрактная фабрика (Abstract Factory)
- Строитель (Builder)
- Фабричный метод (Factory Method)
- Прототип (Prototype)
- Одиночка (Singleton)

7. **GOF** "банды четырёх (GoF)" **Структурные паттерны**

- Структурные паттерны - рассматривает, как классы и объекты образуют более крупные структуры - более сложные по
  характеру классы и объекты. К таким шаблонам относятся:

- Адаптер (Adapter)
- Мост (Bridge)
- Компоновщик (Composite)
- Декоратор (Decorator)
- Заместитель (Proxy)
- Фасад (Facade)
- Приспособленец (Flyweight)

8. **GOF** "банды четырёх (GoF)" **Поведенческие паттерны**

- Поведенческие паттерны - они определяют алгоритмы и взаимодействие между классами и объектами, то есть их поведение.
  Среди подобных шаблонов можно выделить следующие:

- Цепочка обязанностей (Chain of responsibility)
- Команда (Command)
- Интерпретатор (Interpreter)
- Итератор (Iterator)
- Посредник (Mediator)
- Хранитель (Memento)
- Наблюдатель (Observer)
- Состояние (State)
- Стратегия (Strategy)
- Шаблонный метод (Template method)
- Посетитель (Visitor)

9.
10.

TODO//